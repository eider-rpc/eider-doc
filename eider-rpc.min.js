(function(){'use strict';let c='object'==typeof self&&self.self===self&&self||'object'==typeof global&&global.global===global&&global||{},e=c.WebSocket;if(void 0===e)try{e=require('ws')}catch(R){}let g;if(void 0!==e&&(g=e.Server,void 0==g))try{g=require('ws').Server}catch(R){}let h=function(R,S){return Promise.resolve(R).then(T=>{let U=T._enter(),V;try{V=S(U)}catch(W){throw T._exit(),W}return Promise.resolve(V).then(W=>{return T._exit(),W},W=>{throw T._exit(),W})})},j=Symbol.asyncIterator;void 0===j&&(j=Symbol('Symbol.asyncIterator'));const m='__*__';let p={};['AttributeError','CancelledError','DisconnectedError','IndexError','LookupError','RuntimeError'].forEach(R=>{class S extends Error{}S.prototype.name=R,p[R]=S}),p.Exception=Error;let q=function(R){return'_'==R.substring(0,1)||'constructor'==R||'toJSON'==R},r=function(R,S){let T=R[S];if(void 0===T)throw new p.AttributeError('\''+R.constructor.name+'\' object has no attribute \''+S+'\'');if(T===Object.prototype[S])throw new p.AttributeError('Cannot access forbidden attribute \''+S+'\' of \''+R.constructor.name+'\' object');return T};class s{constructor(R,S,T,U=!0){this.name=R,this.encode=S,this.decode=T,this.inband=U,s.registry[R]=this}static byname(R){if(null===R)return null;let S=s.registry[R];if(void 0===S)throw new p.LookupError('Unknown format: '+R);return S}}s.registry={},new s('json',JSON.stringify,JSON.parse);let t;try{t=require('msgpack-lite')}catch(R){void 0!==c.msgpack&&(t=c.msgpack)}if(void 0!==t){let R=t.decode([212,0,0]).constructor,S=function(V){switch(typeof V){case'boolean':case'number':case'string':return V;}return null===V?V:Array.isArray(V)?V.map(S):'function'==typeof V.toJSON?new R(t.encode(V.toJSON()),0):V instanceof ArrayBuffer||'[object ArrayBuffer]'==={}.toString.call(V)?V:ArrayBuffer.isView(V)?V.buffer:Object.keys(V).reduce((W,X)=>{return W[X]=S(V[X]),W},{})},T=t.createCodec({binarraybuffer:!0}),U={codec:T};T.addExtUnpacker(0,V=>new u(t.decode(V,U))),new s('msgpack',V=>t.encode(S(V),U),V=>t.decode(V,U),!1)}class u{constructor(R){this.ref=R}toJSON(){return this.ref}}class v{constructor(R,S=null){this.conn=R,this.lcodec=s.byname(S)}unmarshalAll(R,S,T=null){return R.inband?this.unmarshalAllInBand(S,T):this.unmarshalAllOutOfBand(S,T)}unmarshalAllInBand(R,S=null){switch(typeof R){case'boolean':case'number':case'string':return R;}return null===R?R:Array.isArray(R)?R.map(T=>this.unmarshalAllInBand(T,S)):m in R?this.unmarshal(R,S):Object.keys(R).reduce((T,U)=>{return T[U]=this.unmarshalAllInBand(R[U],S),T},{})}unmarshalAllOutOfBand(R,S=null){switch(typeof R){case'boolean':case'number':case'string':return R;}return null===R?R:Array.isArray(R)?R.map(T=>this.unmarshalAllOutOfBand(T,S)):R instanceof u?this.unmarshal(R.ref,S):R instanceof ArrayBuffer||'[object ArrayBuffer]'==={}.toString.call(R)?R:Object.keys(R).reduce((T,U)=>{return T[U]=this.unmarshalAllOutOfBand(R[U],S),T},{})}unmarshal(R,S){let T=this.unmarshalObj(R,S);if(!('method'in R))return T;let U=R.method;if(q(U))throw new p.AttributeError('Cannot access private attribute \''+U+'\' of \''+T.constructor.name+'\' object');let V=r(T,U);return new Proxy(V,{apply:(W,X,Y)=>W.apply(T,Y)})}_enter(){return this.root()}_exit(){this.close()}}class w extends v{constructor(R,S,T=null,U=null){if(S in R.lsessions)throw new p.RuntimeError('Session ID in use: '+S);super(R,U),this.lsid=S,this.nextloid=0,this.objects={},R.lsessions[S]=this;try{this.objects[null]=(T||R.rootFactory)(this)}catch(V){throw delete R.lsessions[S],V}}root(){return this.objects[null]}add(R){let S=this.nextloid++;return this.objects[S]=R,S}unmarshalObj(R,S){let T=R[m];if('lsid'in R){let V=new G(this.conn,R.lsid,null,S);V.lcodec=this.lcodec;let W=V.unmarshalId(T);return W._closed=!0,W}let U=R.rsid;if(!this.conn.lsessions.hasOwnProperty(U))throw new p.LookupError('Unknown session: '+U);return this.unmarshalId(T)}unmarshalId(R){if(!this.objects.hasOwnProperty(R))throw new p.LookupError('Unknown object: '+R);return this.objects[R]}close(){this.root().release()}}class y{constructor(R,S){return this._lsession=R,this._loid=S,this._lref={lsid:R.lsid,[m]:S},this._nref=1,new Proxy(this,{get:(T,U)=>{let V=T[U];return'function'==typeof V?new Proxy(V,{get:(W,X)=>{let Y=W[X];return'bind'===X?function(Z,...$){let _=Y.call(this,Z,...$);return _.toJSON=()=>({lsid:Z._lsession.lsid,[m]:Z._loid,method:U}),_}:Y}}):V}})}toJSON(){return this._lref}addref(){++this._nref}release(){--this._nref||this._release()}help(R=null){return null===R?this.constructor.help||null:R.help||null}dir(){let R=this,S=[];for(;R!==Object.prototype;)S=S.concat(Object.getOwnPropertyNames(R)),R=Object.getPrototypeOf(R);return S.sort().filter((T,U,V)=>T!==V[U+1]&&!q(T)&&'function'==typeof this[T])}taxa(){let R=Object.getPrototypeOf(this),S=[];for(;null!==R&&R.constructor!==z&&R.constructor!==B;)S.push(R.constructor.name),R=Object.getPrototypeOf(R);return S}signature(R){let S=[];for(let U=0;U<R.length;++U)S.push(['abcdefghijklmnopqrstuvwxyz'.charAt(U),null]);return S.push(['*args',null]),{params:S,defaults:{},'return':null}}_release(){delete this._lsession.objects[this._loid],this._close()}_close(){}_enter(){return this}_exit(){this.release()}}y.prototype.addref.help='Increment the object\'s reference count.',y.prototype.release.help='Decrement the object\'s reference count.  When the reference count reaches zero,\nit will be removed from memory.',y.prototype.help.help='Get documentation for the object or one of its methods.',y.prototype.dir.help='Get a list of names of the object\'s methods.',y.prototype.taxa.help='Get a list of names of the object\'s base classes.',y.prototype.signature.help='Get method type signature.';class z extends y{constructor(R){super(R,null)}_close(){for(let R in this._lsession.objects)this._lsession.objects[R]._close();delete this._lsession.conn.lsessions[this._lsession.lsid]}static setNewables(R,S){S.forEach(T=>{let U=T._new;void 0===U&&(U=(...V)=>new T(...V),U.help=T.help),(R.prototype['new_'+T.name]=function(...V){return U(this._lsession,...V)}).help=U.help})}}class A extends z{open(R,S=null){this._lsession.conn.createLocalSession(R,null,S)}}A.prototype.open.help='Open a new session.';class B extends y{constructor(R){let S=R.nextloid++;super(R,S),R.objects[S]=this}}class D{constructor(R,S){return this._rsession=R,this._roid=S,this._rref={rsid:R.rsid,[m]:S},this._closed=!1,new Proxy(this,{get:(T,U,V)=>{let W=T[U];if(void 0!==W)return W;if('string'==typeof U&&'inspect'!==U&&'then'!==U&&'toJSON'!==U){let X=function(...Y){return R.call(this,U,Y)};return X.bind=function(Y,...Z){let $=Function.prototype.bind.call(this,Y,...Z);return $.toJSON=()=>({rsid:Y._rsession.rsid,[m]:Y._roid,method:U}),$},X.help=()=>V.help(X.bind(V)),X.signature=()=>V.signature(X.bind(V)),X}}})}toJSON(){return this._rref}_close(){return new Promise((R,S)=>{if(this._closed||this._rsession.closed)R();else{this._closed=!0;let T;try{T=this._doclose()}catch(U){U instanceof p.DisconnectedError?R():S(U)}void 0!==T&&T.then(R,U=>{U instanceof p.DisconnectedError?R():S(U)})}})}_doclose(){return this.release()}_enter(){return this}_exit(){this._close()}[j](){return new F(this)}}class F{constructor(R){this.robj=R,this.iter=-1}[j](){return this}next(){let R=this.iter;if(null===R)return Promise.resolve({value:void 0,done:!0});let S=U=>this.robj.get(U).then(V=>{return this.iter=U+1,{value:V,done:!1}},V=>{if(V instanceof p.IndexError)return this.iter=null,{value:void 0,done:!0};throw this.iter=null,V}),T=U=>U.next().then(V=>{return V.done?(this.iter=null,U._close(),{value:void 0,done:!0}):{value:V.value,done:V.done}},V=>{throw this.iter=null,U._close(),V});return-1===R?this.robj.iter().then(U=>{return this.iter=U,T(U)},U=>{if(U instanceof p.AttributeError)return this.iter=0,S(0);throw this.iter=null,U}):'number'==typeof R?S(R):T(R)}close(){let R=this.iter;this.iter=null,R instanceof D&&R._close()}_enter(){return this}_exit(){this.close()}}class G extends v{constructor(R,S,T=null,U=null){super(R,T),this.rsid=S,this.dstid=U}call(R,S,T=[]){let U=this.conn.nextrcid++;this.conn.sendcall(this.lcodec,this.dstid,U,R,S,T);let V=new Promise((W,X)=>{this.conn.rcalls[U]={rsession:this,resolve:W,reject:X}});return V.cancel=()=>{let W=this.conn.rcalls[U];void 0!==W&&(delete this.conn.rcalls[U],this.conn.send({dst:this.dstid,cancel:U}),W.reject(new p.CancelledError))},V}unmarshalObj(R){let S=R[m];if('rsid'in R){let V=R.rsid;if(!this.conn.lsessions.hasOwnProperty(V))throw new p.LookupError('Unknown session: '+V);let W=this.conn.lsessions[V];return W.unmarshalId(S)}let T=R.lsid;if(T!==this.rsid)throw new p.LookupError('Unknown session: '+T);let U=this.unmarshalId(S);return'bridge'in R?this.unmarshalBridge(U,R.bridge):U}unmarshalBridge(R,S){return new J(R,S)}unmarshalId(R){return new D(this,R)}}class H extends G{constructor(R,S,T=null,U=null,V=null){super(R,S,T,V),Promise.resolve(this._open(U)).catch(()=>{}),this.closed=!1,this._root=this.unmarshalId(null)}root(){return this._root}close(){this.closed||(this.closed=!0,this._close())}}class I extends H{constructor(R,S=null,T=null){super(R,R.nextrsid++,S,T)}_open(R){return this.call(null,'open',[this.rsid,R])}_close(){return this._root._close()}}class J extends H{constructor(R,S){super(R._rsession.conn,S.rsid,S.lformat,null,S.dst),this.bridge=R}_open(){}_close(){return this.bridge._close()}}class K extends B{constructor(R,S,T='json',U='json'){super(R),this._rsession=new I(S,null,U),this._lref.bridge={dst:S.id,rsid:this._rsession.rsid,lformat:T}}_close(){this._rsession.close()}}K.help='Bridge between clients.  Allows one client to call methods exposed by\nanother client.';class L{constructor(){this.objects={},this.nextid=0}add(R){let S=this.nextid++;return this.objects[S]=R,S}get(R){return this.objects[R]}remove(R){delete this.objects[R]}}let M=new L;class N{constructor(R,S={}){if(S.rootFactory)this.rootFactory=S.rootFactory;else{let U=S.root||z;this.rootFactory=V=>new U(V)}this.onopen=S.onopen||(()=>{}),this.onclose=S.onclose||(()=>{}),this.log=S.log||((...U)=>{console.log(...U)}),this.lencode=s.registry[S.lformat||'json'].encode,this.rcodec=s.registry[S.rformat||'json'],this.rcodecBin=s.registry[S.rformatBin||'msgpack'],this.lsessions={},this.lcalls={},this.rcalls={},this.bcalls={},this.nextrsid=0,this.nextrcid=0,this.header=null,this.headerRcodec=null,new w(this,null,U=>new A(U)),this.registry=S.registry?S.registry:M,this.id=this.registry.add(this);let T='string'==typeof R?new e(R):R;3===T.readyState?(this.ws=null,this.registry.remove(this.id),setTimeout(()=>this.onclose(this),0)):(this.ws=T,1===T.readyState?setTimeout(()=>this.onopen(this),0):T.onopen=()=>{this.onopen(this)},T.onclose=()=>{this.ws=null,this.lclose(),this.rclose(),this.onclose(this)},T.onmessage=U=>{if(null===this.header){let V='string'==typeof U.data?this.rcodec:this.rcodecBin,W;try{W=V.decode(U.data)}catch(X){return this.log('Invalid data received on Eider WebSocket connection:',X),void this.close()}'format'in W&&null!==W.format?(this.header=W,this.headerRcodec=V):this.dispatch(V,W)}else this.dispatch(this.headerRcodec,this.header,U.data),this.header=null})}createLocalSession(R=-2,S=null,T=null){return new w(this,R,S,T)}createSession(R=null,S=null){return new I(this,R,S)}dispatch(R,S,T=null){let U=S.dst;void 0===U&&(U=null);let V=S.method;if(V){let W=S.id;if(void 0===W&&(W=null),null===U){let X=S.src;void 0===X&&(X=null);try{if(q(V))throw new p.AttributeError('Cannot call private method \''+V+'\'');let Y;null===T?Y=S:(R=s.byname(S.format),Y=R.decode(T));let[Z,$]=this.applyBegin(R,X,V,Y),_=Z.lcodec;try{let aa=this.applyFinish(R,X,V,Z,$,Y);null!==W&&aa&&'function'==typeof aa.then&&'function'==typeof aa.cancel&&(this.lcalls[W]=aa),Promise.resolve(aa).then(ba=>{null!==W&&(W in this.lcalls&&delete this.lcalls[W],this.respond(X,W,ba,_))}).catch(ba=>{W in this.lcalls&&delete this.lcalls[W],this.onError(X,W,ba,_)})}catch(aa){this.onError(X,W,aa,_)}}catch(Y){this.onError(X,W,Y)}}else this.bridgeCall(U,W,S,T)}else{let W=S.cancel;if(void 0===W||null===W){let X=S.id;if(null===U){let Y=this.rcalls[X];if(void 0!==Y){delete this.rcalls[X];try{let Z;null===T?Z=S:(R=s.byname(S.format),Z=R.decode(T)),Y.resolve(this.getresult(R,Y.rsession,Z))}catch(Z){Y.reject(Z)}}}else this.bridgeResponse(U,X,S,T)}else if(null===U){let X=this.lcalls[W];void 0!==X&&(delete this.lcalls[W],X.cancel())}else this.bridgeCall(U,null,S,T)}}bridgeCall(R,S,T,U){let V=this.registry.get(R);void 0===V?this.onError(null,S,new p.DisconnectedError('Unknown connection: '+R)):(delete T.dst,T.src=this.id,V.send(T,U),null!==S&&((V.bcalls[this.id]||(V.bcalls[this.id]={}))[S]=1))}bridgeResponse(R,S,T,U){let V=this.registry.get(R);void 0!==V&&(this.bcalls[R]&&this.bcalls[R][S]&&delete this.bcalls[R][S],delete T.dst,V.send(T,U))}applyBegin(R,S,T,U){let V=U.this,W,X;if(void 0===V||null===V)W=null,X=null;else if(Array.isArray(V))throw new TypeError('Malformed this object');else V instanceof u&&(V=V.ref),W=V[m],void 0===W&&(W=null),X=V.rsid,void 0===X&&(X=null);if(!this.lsessions.hasOwnProperty(X))throw new p.LookupError('Unknown session: '+X);return[this.lsessions[X],W]}applyFinish(R,S,T,U,V,W){if(!U.objects.hasOwnProperty(V))throw new p.LookupError('Unknown object: '+V);let X=U.objects[V],Y=r(X,T),Z='params'in W?U.unmarshalAll(R,W.params,S):[];return Y.apply(X,Z)}getresult(R,S,T){if('result'in T)return S.unmarshalAll(R,T.result);let U=T.error;if(!U)throw new Error('Unspecified error');let V=U.message;V=void 0===V||''===V?'Unspecified error':''+V;let W=''+U.name,X=p[W]||c[W];'function'==typeof X&&(X===Error||X.prototype instanceof Error)||(X=Error,W&&(V=W+': '+V));let Y=U.stack,Z=new X(V);throw'string'==typeof Y&&('string'==typeof Z.stack?Z.stack=Y.trim()+'\n\nThe above exception was the direct cause of the following exception:\n\n'+Z.stack:Z.stack=Y),Z}onError(R,S,T,U=null){null===S?this.log(T):((void 0===T.name||void 0===T.message)&&(T=new Error(T)),this.error(R,S,T,U))}close(){null!==this.ws&&(this.ws.close(),this.ws=null)}lclose(){for(let R in this.lsessions)this.lsessions[R].objects[null]._release()}rclose(){for(let R in this.registry.remove(this.id),this.lcalls)this.lcalls[R].cancel();for(let R in this.rcalls)this.rcalls[R].reject(new p.DisconnectedError('Connection lost'));for(let R in this.bcalls){let S=this.registry.get(R);if(void 0!==S)for(let T in this.bcalls[R])S.error(null,T,new p.DisconnectedError('Bridged connection lost'))}for(let R in this.registry.objects){let S=this.registry.objects[R],T=S.bcalls[this.id];if(void 0!==T&&(delete S.bcalls[this.id],null!==S.ws))for(let U in T)S.send({cancel:U})}}sendcall(R,S,T,U,V,W=[]){if(null===this.ws)throw new p.DisconnectedError('Connection closed');let X={dst:S,id:T,method:V},Y;null===R?(Y=null,X.this=U,X.params=W):(Y=R.encode({this:U,params:W}),X.format=R.name),this.send(X,Y)}respond(R,S,T,U){void 0===T&&(T=null);let V={dst:R,id:S},W;if(null===U)W=null,V.result=T;else{try{W=U.encode({result:T})}catch(X){return void this.error(R,S,X,U)}V.format=U.name}this.send(V,W)}error(R,S,T,U=null){let V={dst:R,id:S},W={name:T.name,message:T.message};'string'==typeof T.stack&&(W.stack=T.stack);let X;if(null===U)X=null,V.error=W;else try{X=U.encode({error:W}),V.format=U.name}catch(Y){X=null,V.error=W}this.send(V,X)}send(R,S=null){null!==this.ws&&(this.ws.send(this.lencode(R)),null!==S&&this.ws.send(S))}_enter(){return this}_exit(){this.close()}}let O=function(R,S={}){return new Promise((T,U)=>{let V=new N(R,S),W=S.onclose||(()=>{});V.onopen=X=>{X.onclose=W,T(X)},V.onclose=X=>{U(new Error('Could not connect')),W(X)}})},Q={asyncIterator:j,Bridge:K,Codec:s,connect:O,Connection:N,Errors:p,forEachAsync:(R,S)=>h(R[j](),T=>{let U=()=>T.next().then(V=>{if(!V.done)return Promise.resolve(S(V.value)).then(U)});return U()}),LocalObject:B,LocalRoot:z,Reference:u,Registry:L,serve:function(R,S={}){let T=new g({port:R});return T.on('connection',U=>O(U,S)),T},using:h,VERSION:'0.9.4'};'undefined'!=typeof module&&!module.nodeType&&module.exports?module.exports=Q:c.Eider=Q})();
